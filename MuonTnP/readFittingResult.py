import ROOT
import numpy as np
import argparse

parser = argparse.ArgumentParser()
parser.add_argument("-f", help="The folder which save results")
parser.add_argument("-n", type=int, default=7, help="The total bin numbers")
args = parser.parse_args()

def makeLegend(legend, **hist):
	legend.AddEntry(hist["mc"], "DYJetsToLL 2018", "PL")
	legend.AddEntry(hist["data"], "Data 2018", "PL")

filesDict = {"ID": "tpTree/Tight_pt/fit_eff", "Iso": "tpTree/Iso_loose_pt/fit_eff", "Trigger": "tpTree/Trigger_pt/fit_eff"}
fileYAxis = {"ID": "ID/Trk.", "Iso": "PFIso/ID", "Trigger": "Trigger/PFIso"}
edgeArray = np.array([0, 45, 80, 120, 200, 350, 450, 600], 'd')
binCenterArray = (edgeArray[0:-1] + edgeArray[1:]) / 2
binWidth = np.diff(edgeArray) / 2
print(binWidth)
for effType, pathName in filesDict.items():
	print("Read {}".format(effType))
	mcEffArray = np.array([], 'd')
	mcEffUpError = np.array([], 'd')
	mcEffDownError = np.array([], 'd')
	dataEffArray = np.array([], 'd')
	dataEffUpError = np.array([], 'd')
	dataEffDownError = np.array([], 'd')
	for binNum in range(args.n):
		print("Read TnP_Muon_{}.root".format(binNum))
		mcF = ROOT.TFile("./{}/MC_TnP_Muon_{}_{}.root".format(args.f, effType, binNum), "read")
		dataF = ROOT.TFile("./{}/Data_TnP_Muon_{}_{}.root".format(args.f, effType, binNum), "read")
		mcResults = mcF.Get(pathName)
		dataResults = dataF.Get(pathName)
		mcEffsResults = mcResults.get(0)
		dataEffsResults = dataResults.get(0)
		mcEff = mcEffsResults.find("efficiency")
		if not mcEff:
			mcEffArray = np.append(mcEffArray, 0)
			mcEffUpError = np.append(mcEffUpError, 0)
			mcEffDownError = np.append(mcEffDownError, 0)
		else:
			mcEffArray = np.append(mcEffArray, mcEff.getVal())
			mcEffUpError = np.append(mcEffUpError, mcEff.getAsymErrorHi())
			mcEffDownError = np.append(mcEffDownError, mcEff.getAsymErrorLo())
			
		dataEff = dataEffsResults.find("efficiency")
		if not dataEff:
			dataEffArray = np.append(dataEffArray, 0)
			dataEffUpError = np.append(dataEffUpError, 0)
			dataEffDownError = np.append(dataEffDownError, 0)
		else:
			dataEffArray = np.append(dataEffArray, dataEff.getVal())
			dataEffUpError = np.append(dataEffUpError, dataEff.getAsymErrorHi())
			dataEffDownError = np.append(dataEffDownError, dataEff.getAsymErrorLo())
		mcF.Close()
		dataF.Close()
	mcGraph = ROOT.TGraphAsymmErrors(args.n, binCenterArray, mcEffArray, binWidth, binWidth, mcEffDownError, mcEffUpError)
	dataGraph = ROOT.TGraphAsymmErrors(args.n, binCenterArray, dataEffArray, binWidth, binWidth, dataEffDownError, dataEffUpError)
	mcGraph.SetMarkerStyle(24)
	mcGraph.SetMarkerColor(ROOT.kBlue)
	mcGraph.SetLineColor(ROOT.kBlue)
	dataGraph.SetMarkerStyle(20)
	
	effMultiGraph = ROOT.TMultiGraph()
	effMultiGraph.Add(mcGraph)
	effMultiGraph.Add(dataGraph)
	effMultiGraph.GetXaxis().SetTitle("Probe Muon p_{T} [GeV]")
	effMultiGraph.GetYaxis().SetTitle("Efficiency {}".format(fileYAxis[effType]))
	effMultiGraph.GetYaxis().SetTitleSize(0.045)
	effMultiGraph.GetYaxis().SetLabelSize(0.045)
	effMultiGraph.GetYaxis().SetRangeUser(0.7, 1.2)
	effMultiGraph.GetXaxis().SetLimits(edgeArray[0], edgeArray[-1])
	effMultiGraph.SetTitle("")
	covDataMCUp = np.cov(dataEffUpError, mcEffUpError)
	covDataMCDown = np.cov(dataEffDownError, mcEffDownError)
	ratioEffArray = dataEffArray / mcEffArray
	#ratioEffUpError = np.abs(dataEffUpError / mcEffUpError) * np.sqrt((np.std(dataEffUpError) / dataEffUpError) ** 2 + (np.std(mcEffUpError) / mcEffUpError) ** 2 - 2 * covDataMCUp[0][1] / (dataEffUpError * mcEffUpError))
	#ratioEffDownError = np.abs(dataEffDownError / mcEffDownError) * np.sqrt((np.std(dataEffDownError) / dataEffDownError) ** 2 + (np.std(mcEffDownError) / mcEffDownError) ** 2 - 2 * covDataMCDown[0][1] / (dataEffDownError * mcEffDownError))
	passEffArray = dataEffArray / (dataEffArray + mcEffArray)
	print(dataEffUpError, mcEffUpError, passEffArray)
	ratioEffUpError = (1 / (1 - passEffArray ** 2)) * (dataEffUpError / mcEffUpError)
	ratioEffDownError = (1 / (1 - passEffArray ** 2)) * (dataEffDownError / mcEffDownError)
	ratioGraph = ROOT.TGraphAsymmErrors(args.n, binCenterArray, ratioEffArray, binWidth, binWidth, ratioEffDownError, ratioEffUpError)
	ratioGraph.SetTitle("")
	ratioGraph.GetXaxis().SetLimits(edgeArray[0], edgeArray[-1])
	ratioGraph.GetXaxis().SetLabelSize(0.14)
	ratioGraph.GetXaxis().SetTitleSize(0.14)
	ratioGraph.GetXaxis().SetTitle("Probe Muon p_{T} [GeV]")
	ratioGraph.GetYaxis().SetRangeUser(0.8, 1.2)
	ratioGraph.GetYaxis().SetTitle("Data/MC")
	ratioGraph.GetYaxis().SetLabelSize(0.13)
	ratioGraph.GetYaxis().SetTitleSize(0.13)
	ratioGraph.GetYaxis().SetTitleOffset(0.4)
	ratioGraph.GetYaxis().SetNdivisions(505)
	ratioGraph.SetMarkerStyle(20)
	leg = ROOT.TLegend(0.7, 0.7, 0.9, 0.9)
	#leg.AddEntry(mcGraph, "DYJetsToLL 2018", "PL")
	#leg.AddEntry(dataGraph, "Data 2018", "PL")
	makeLegend(leg, mc=mcGraph, data=dataGraph)
	c = ROOT.TCanvas("c", "", 800, 600)
	upperPad = ROOT.TPad("upperPad", "upperPad", 0., 0.3, 1. , 1.)
	lowerPad = ROOT.TPad("lowerPad", "lowerPad", 0., 0., 1. , 0.3)
	upperPad.Draw()
	lowerPad.Draw()
	upperPad.SetTicks(1, 1)
	upperPad.SetBottomMargin(0.)
	upperPad.cd() # active uppper pad
	effMultiGraph.Draw("ap")
	leg.Draw("same")
	lowerPad.cd()
	lowerPad.SetTopMargin(0.)
	lowerPad.SetTicks(1, 1)
	lowerPad.SetGridy()
	lowerPad.SetBottomMargin(0.4)
	ratioGraph.Draw("ap")
	c.SaveAs("ratio_{}.pdf".format(effType))
	del(leg) # I don't understand the reason, but it makes the script work